

{/\
  Removes the points that are inside or outside the distance Dist from the point (x, y) from the TPointArray ThePoints.
/\}

function RemoveDistTPointArray(x, y, dist: Integer;const ThePoints: TPointArray; RemoveHigher: Boolean): TPointArray;
var
  I, L, LL: integer;
begin;
  L := 0;
  LL := Length(ThePoints) -1;
  SetLength(Result, LL + 1);
  if RemoveHigher then
  begin;
    for I := 0 to LL do
      if not (Round(sqrt(sqr(ThePoints[i].x - x)+sqr(ThePoints[i].y - y))) > Dist) then
      begin;
        Result[L] := ThePoints[i];
        L := L + 1;
      end;
  end else
  begin;
    for I := 0 to LL do
      if not (Round(sqrt(sqr(ThePoints[i].x - x)+sqr(ThePoints[i].y - y))) < Dist) then
      begin;
        Result[L] := ThePoints[i];
        L := L + 1;
      end;
  end;
  SetLength(Result,L);
end;

{/\
  Returns the boundaries of the ATPA as a TBox.
/\}

function GetATPABounds(const ATPA: T2DPointArray): TBox;
var
  I,II,L2,L : Integer;
begin;
  FillChar(result,sizeof(TBox),0);
  L := High(ATPA);
  if (l < 0) then Exit;
  For I := 0 to L do
    if Length(ATPA[I]) > 0 then
    begin;
      Result.x1 := ATPA[I][0].x;
      Result.y1 := ATPA[I][0].y;
      Result.x2 := ATPA[I][0].x;
      Result.y2 := ATPA[I][0].y;
    end;
  for I := 0 to L do
  begin;
    L2 := High(ATPA[I]);
    for II := 0 to L2 do
    begin;
      if ATPA[i][II].x > Result.x2 then
        Result.x2 := ATPA[i][II].x
      else if ATPA[i][II].x < Result.x1 then
        Result.x1 := ATPA[i][II].x;
      if ATPA[i][II].y > Result.y2 then
        Result.y2 := ATPA[i][II].y
      else if ATPA[i][II].y < Result.y1 then
        Result.y1 := ATPA[i][II].y;
    end;
  end;
end;

{/\
  Returns the boundaries of the TPA as a TBox.
/\}

function GetTPABounds(const TPA: TPointArray): TBox;
var
  I,L : Integer;
begin;
  FillChar(result,sizeof(TBox),0);
  L := High(TPA);
  if (l < 0) then Exit;
  Result.x1 := TPA[0].x;
  Result.y1 := TPA[0].y;
  Result.x2 := TPA[0].x;
  Result.y2 := TPA[0].y;
  for I:= 1 to L do
  begin;
    if TPA[i].x > Result.x2 then
      Result.x2 := TPA[i].x
    else if TPA[i].x < Result.x1 then
      Result.x1 := TPA[i].x;
    if TPA[i].y > Result.y2 then
      Result.y2 := TPA[i].y
    else if TPA[i].y < Result.y1 then
      Result.y1 := TPA[i].y;
  end;
end;

{/\
  Looks for the TPA SearchTPA in the TPA TotalTPA and returns the matched points
  \\ to the TPA Matches. Returns true if there were atleast one match(es).
/\}

function FindTPAinTPA(SearchTPA : TPointArray; const TotalTPA: TPointArray; var Matches: TPointArray): Boolean;
var
  Len, I,II,LenSearch,xOff,yOff : integer;
  tx,ty,MatchCount : integer;
  Screen : T2DBoolArray;
  ScreenBox,SearchBox : TBox;
  Found: Boolean;
begin;
  Result := False;
  Len := High(TotalTPA);
  LenSearch := High(SearchTPA);
  if LenSearch < 0 then Exit;
  if Len < LenSearch then Exit;
  MatchCount := 0;
  ScreenBox := GetTPABounds(TotalTPA);
  SearchBox := GetTPABounds(SearchTPA);
  try
    SetLength(Screen,ScreenBox.x2 + 1,ScreenBox.y2 + 1);
    for i := ScreenBox.x2 downto 0 do
      FillChar(Screen[i][0],screenbox.y2+1,0);
  except
    Exit;
  end;
  if (SearchBox.x1 > 0) or (SearchBox.y1 > 0) then
  begin;
    for I := 0 to LenSearch do
    begin;
      SearchTPA[I].x := SearchTPA[I].x - SearchBox.x1;
      SearchTPA[I].y := SearchTPA[I].y - SearchBox.y1;
    end;
    SearchBox.x2 := SearchBox.x2 - SearchBox.x1;
    SearchBox.y2 := SearchBox.y2 - SearchBox.y1;
    SearchBox.x1 := 0;
    SearchBox.y1 := 0;
  end;
  xOff := SearchBox.x2;
  yOff := SearchBox.y2;
  for I := 0 to LenSearch do
  begin;
    if (SearchTPA[I].x = 0) and (SearchTPA[I].y < yOff) then
        yOff := SearchTPA[I].y;
    if (SearchTPA[I].y = 0) and (SearchTPA[I].x < xOff) then
        xOff := SearchTPA[I].x;
  end;
  for I := 0 to Len do
    Screen[TotalTPA[I].x][TotalTPA[I].y] := True;
  for I := 0 to Len do
  begin;
    tx := TotalTPA[I].x - xOff;
    ty := TotalTPA[I].y;// - yOff;
    if tx > 0 then
      if ty > 0 then
        if ((SearchBox.x2 + tx) <= ScreenBox.x2) and ((SearchBox.y2 + ty) <= ScreenBox.y2) then
          begin;
            Found := false;
            For II := 0 to LenSearch do
              if Screen[tx + SearchTPA[II].x ][ty + SearchTPA[II].y] = False then
              begin
                Found := True;
                Break;
              end;
            if not found then
//            if II > LenSearch then
            begin;
              MatchCount := MatchCount + 1;
              SetLength(Matches,MatchCount);
              Matches[MatchCount - 1].x := TotalTPA[I].x;
              Matches[MatchCount - 1].y := TotalTPA[I].y;
            end;
          end;
  end;
  if (MatchCount > 0) then
    Result := True;
end;

{/\
  Read the description of FindTPAinTPA. Additional Height parameter.
/\}

function FindTextTPAinTPA(Height : integer;const SearchTPA, TotalTPA: TPointArray; var Matches: TPointArray): Boolean;
var
  Len, I,II,LenSearch,LenTPA,xOff,yOff,x,y: integer;
  tx,ty,MatchCount : integer;
  Found : boolean;
  Screen : T2DBoolArray;
  ScreenBox,SearchBox : TBox;
  InversedTPA : TPointArray;
begin;
  Result := False;
  Len := High(TotalTPA);
  LenSearch := High(SearchTPA);
  if LenSearch < 0 then Exit;
  if Len < LenSearch then Exit;
  MatchCount := 0;
  xOff := -5;
  yOff := 0;
  ScreenBox := GetTPABounds(TotalTPA);
  SearchBox := GetTPABounds(SearchTPA);
  if height > SearchBox.y2 then
    Screenbox.y2 := Screenbox.y2 + (height - SearchBox.y2);
  SearchBox.y2 := Height;
  SetLength(Screen, SearchBox.x2 + 1,SearchBox.y2 + 1);
  for i := SearchBox.x2 downto 0 do
    FillChar(screen[i][0],SearchBox.y2+1,0);
  SetLength(InversedTPA,(SearchBox.x2 + 1) * (Searchbox.y2 + 1));
  for I := 0 to LenSearch do
    Screen[ SearchTPA[I].x,SearchTPA[I].y] := True;
  LenTPA := -1;
  for y := 0 to SearchBox.y2 do
    for x := 0 to SearchBox.x2 do
      if Screen[X][Y] = False then
      begin;
        LenTPA := LenTPA + 1;
        InversedTPA[LenTPA].x := x;
        InversedTPA[LenTPA].y := y;
      end;
  for x := 0 to SearchBox.x2 do
  begin;
    for y := 0 to SearchBox.y2 do
      if Screen[x][y] = True then
      begin;
        xOff := x;
        yOff := y;
        Break;
      end;
    if xOff >= 0 then
      Break;
  end;
  try
    SetLength(Screen,0);
    SetLength(Screen,ScreenBox.x2 + 1,ScreenBox.y2 + 1);
    for i := ScreenBox.x2 downto 0 do
      FillChar(screen[i][0],screenbox.y2+1,0);
  except
    Exit;
  end;
  for I := 0 to Len do
    Screen[TotalTPA[I].x][TotalTPA[I].y] := True;
  for I := 0 to Len do
  begin;
    tx := TotalTPA[I].x - xOff;
    ty := TotalTPA[I].y - yOff;
    if tx > 0 then
      if ty > 0 then
        if ((SearchBox.x2 + tx) <= ScreenBox.x2) and ((SearchBox.y2 + ty) <= ScreenBox.y2) then
          begin;
            Found := false;
            For II := 0 to LenSearch do
              if Screen[tx + SearchTPA[II].x ][ty + SearchTPA[II].y] = False then
              begin
                Found := true;
                Break;
              end;
            if (not Found) then
            begin;
              Found := false;
              For II := 0 to LenTPA do
                if Screen[tx + InversedTPA[II].x ][ty + InversedTPA[II].y] = True then
                begin
                  Found := true;
                  Break;
                end;
              if (not Found) then
              begin;
                MatchCount := MatchCount + 1;
                SetLength(Matches,MatchCount);
                Matches[MatchCount - 1].x := TotalTPA[I].x;
                Matches[MatchCount - 1].y := TotalTPA[I].y;
              end;
            end;
          end;
  end;
  if (MatchCount > 0) then
    Result := True;
end;

{/\
  Finds the points that exist in all TPA's in the ATPA.
/\}

function GetSamePointsATPA(const ATPA : T2DPointArray; var Matches : TPointArray) : boolean;
var
  I,ii,Len,MatchesC : integer;
  MinBox,TempBox : TBox;
  Grid : Array of Array of LongWord;
  CompareValue : Longword;
  W,H,x,y: integer;
begin;
  len := high(ATPA);
  result := false;
  if len >= 31 then
  begin;
    Writeln('You cannot have more than 32 TPA''s in your ATPA for this function');
    exit;
  end;
  if len <= 0 then
  begin;
    Writeln('You''d need more than 1 TPA for this function');
    exit;
  end;
  MinBox.x1 := 0;
  MinBox.y1 := 0;
  MinBox.x2 := MaxInt;
  MinBox.y2 := MaxInt;
  for i := 0 to len do
    if Length(ATPA[i]) = 0 then
      Exit
    else
    begin
      TempBox := GetTPABounds(ATPA[i]);
      MinBox.x1 := Max(MinBox.x1,TempBox.x1);
      MinBox.y1 := Max(MinBox.y1,TempBox.y1);
      MinBox.x2 := Min(MinBox.x2,TempBox.x2);
      MinBox.y2 := Min(MinBox.y2,TempBox.y2);
    end;
  w := MinBox.x2-minbox.x1;
  h := minbox.y2 - minbox.y1;
  Writeln(format('(%d,%d,%d,%d)',[minbox.x1,minbox.y1,minbox.x2,minbox.y2]));
  SetLength(Grid,w + 1);
  for i := (W) downto 0 do
  begin;
    setlength(grid[i],H + 1);
    FillChar(grid[i][0],SizeOf(LongWord) * (H + 1),0);
  end;
  for i := 0 to len do
    for ii := high(ATPA[i]) downto 0 do
      if (ATPA[i][ii].x >= MinBox.x1) and (ATPA[i][ii].x <= MinBox.x2) and
         (ATPA[i][ii].y >= MinBox.y1) and (ATPA[i][ii].y <= MinBox.y2) then
        Grid[ATPA[i][ii].x-MinBox.x1][ATPA[i][ii].y-MinBox.y1] :=
             Grid[ATPA[i][ii].x-MinBox.x1][ATPA[i][ii].y-MinBox.y1] or (1 shl i);//Set that this TPA has this point..
  CompareValue := 0;
  for i := 0 to len do
    CompareValue := CompareValue or (1 shl i);
  SetLength(matches, (W+1) * (H+ 1));
  MatchesC := 0;
  for y := 0 to H do
    for x := 0 to W do
      if Grid[x][y] = CompareValue then
      begin;
        Matches[MatchesC].x := x + minbox.x1;
        Matches[MatchesC].y := y + minbox.y1;
        inc(MatchesC);
      end;
  result := (MatchesC <> 0);
  setlength(matches,MatchesC);
end;
{/\
  Finds the possible gaps in the TPointArray TPA and results the gaps as a T2DPointArray.
  \\ Considers as a gap if the gap length is >= MinPixels.
  \\ Only horizontal, sorry folks.
/\}

function FindGapsTPA(const TPA: TPointArray; MinPixels: Integer): T2DPointArray;
var
  Len,TotalLen,LenRes,I,II,III : integer;
  Screen : T2DBoolArray;
  Height,Width : Integer;
  Box : TBox;
begin;
  Len := High(TPA);
  if Len < 0 then exit;
  Box := GetTPABounds(TPA);
  Height := Box.y2 - Box.y1;
  Width := Box.x2 - Box.x1;
  LenRes := 0;
  III := 0;
  try
    SetLength(Screen,Width + 1,Height + 1);
    for i := 0 to Width do
      FillChar(Screen[i][0],(Height+1),0);
  except
    Exit;
  end;
  For I := 0 to Len do
    Screen[TPA[I].x - Box.x1][TPA[I].y - Box.y1] := True;
  SetLength(result,1);
  SetLength(Result[0],Len+1);
  TotalLen := 0;
  for I := 0 to Width do
  begin;
    for II := 0 to Height do
      if Screen[I][II]=True then
      begin;
        Result[TotalLen][LenRes].x := I + Box.x1;
        Result[TotalLen][LenRes].y := II + Box.y1;
        LenRes := LenRes + 1;
        III := I;
      end;
    if LenRes = 0 then
      III := I
    else
    if (I - III) > MinPixels then
    begin;
      III := I;
      SetLength(Result[TotalLen],LenRes);
      LenRes := 0;
      TotalLen := TotalLen + 1;
      SetLength(Result,TotalLen + 1);
      SetLength(Result[TotalLen],Len + 1);
    end;
  end;
  SetLength(Result[TotalLen],LenRes);
end;



{/\
  Sorts all points in tpa by distance from degree (Deg) and distance from mx and my.
  \\ Sortup will return closest distance to mx and my first.
  \\ Distance will be sorted first (RadialWalk style).
/\}

procedure SortCircleWise(var tpa: TPointArray; const cx, cy, StartDegree: Integer; SortUp, ClockWise: Boolean);
const
  i180Pi = 57.29577951;
var
  i, l, td, sd: Integer;
  Dist, Deg: TIntegerArray;
begin
  l := Length(tpa);
  if (l = 0) then Exit;
  sd := StartDegree;
  while (sd > 360) do
    sd := (sd - 360);
  sd := (360 - sd);
  SetLength(Dist, l);
  SetLength(Deg, l);
  for i := 0 to l -1 do
    Dist[i] := Round(Hypot(tpa[i].x - cx, tpa[i].y - cy));
  QuickTPASort(Dist, tpa, 0, l -1, SortUp);
  if (l = 1) then Exit;
  for i := 0 to l -1 do
  begin
    td := Round(ArcTan2(tpa[i].y - cy, tpa[i].x - cx) * i180Pi) + 90;
    if (td < 0) then
      td := td + 360;
    if ClockWise then
      Deg[i] := Round(sd + td) mod 360
    else
      Deg[i] := 360 - Round(sd + td) mod 360;
  end;
  i := 1;
  td := 0;
  Dec(l);
  while (i < l) do
  begin
    while (i < l) and (Abs(Dist[td] - Dist[i]) <= 1) do Inc(i);
    QuickTPASort(Deg, tpa, td, i, False);
    Inc(i);
    td := i;
  end;
  if (td < l) then
    QuickTPASort(Deg, tpa, td, l, False);
end;

{/\
  Sorts all points in tpa by distance from degree (Deg) and distance from mx and my.
  \\ Sortup will return closest distance to mx and my first.
  \\ Degree will be sorted first (LinearWalk style).
/\}

procedure LinearSort(var tpa: TPointArray; cx, cy, sd: Integer; SortUp: Boolean);
const
  i180Pi = 57.29577951;
var
  i, l, td: Integer;
  Dist, Deg: TIntegerArray;
begin
  l := Length(tpa);
  if (l = 0) then Exit;
  while (sd > 360) do
    sd := (sd - 360);
  SetLength(Dist, l);
  SetLength(Deg, l);
  for i := 0 to l -1 do
  begin
    td := Round(ArcTan2(tpa[i].y - cy, tpa[i].x - cx) * i180Pi) + 90;
    if (td < 0) then
      td := td + 360;
    Deg[i] := Min(Abs(sd - td), Min(Abs(sd - (td + 360)), Abs((sd + 360) - td)))
  end;
  QuickTPASort(Deg, tpa, 0, l -1, True);
  if (l = 1) then Exit;
  for i := 0 to l -1 do
    Dist[i] := Round(Hypot(tpa[i].x - cx, tpa[i].y - cy));
  i := 1;
  td := 0;
  Dec(l);
  while (i < l) do
  begin
    while (i < l) and (Abs(Deg[td] - Deg[i]) <= 3) do Inc(i);
    QuickTPASort(Dist, tpa, td, i, SortUp);
    Inc(i);
    td := i;
  end;
  if (td < l) then
    QuickTPASort(Dist, tpa, td, l, SortUp);
end;

{/\
  Merges the TPointArrays of the T2DPointArray ATPA in to one TPA.
/\}

Function MergeATPA(const ATPA: T2DPointArray): TPointArray;
var
  I, II, Len, TempL, CurrentL: integer;
begin;
  Len := High(ATPA);
  if Len < 0 then
  begin
    SetLength(Result, 0);
    Exit;
  end;
  CurrentL := 0;
  For I:= 0 to Len do
  begin;
    TempL := High(ATPA[I]);
    if TempL < 0 then
      Continue;
    TempL := Templ + CurrentL + 1;
    Setlength(Result, TempL+1);
    For II := CurrentL to TempL do
      Result[II] := ATPA[I][II - CurrentL];
    CurrentL := TempL;
  end;
  SetLength(Result,CurrentL);
end;

{/\
  Appends ToAppend array to the end of TPA.
/\}
procedure AppendTPA(var TPA: TPointArray; const ToAppend: TPointArray);
var
  l,lo,i : integer;
begin
  l := high(ToAppend);
  lo := length(TPA);
  setlength(TPA,lo + l  + 1);
  for i := 0 to l do
    TPA[i + lo] := ToAppend[i];
end;

{/\
  Returns a TPointArray of a line specified by the end points x1,y1 and x2,y2.
/\}
function TPAFromLine(const x1, y1, x2, y2: Integer): TPointArray;
var
  Dx, Dy, CurrentX, CurrentY, Len, TwoDx, TwoDy, Xinc, YInc: Integer;
  TwoDxAccumulatedError, TwoDyAccumulatedError: Integer;
begin
  Len := 0;
  Dx := (X2-X1);
  Dy := (Y2-Y1);
  TwoDx := Dx + Dx;
  TwoDy := Dy + Dy;
  CurrentX := X1;
  CurrentY := Y1;
  Xinc := 1;
  Yinc := 1;
  if (Dx < 0) then
  begin
    Xinc := -1;
    Dx := - Dx;
    TwoDx := - TwoDx;
  end;
  if (Dy < 0) then
  begin
    Yinc := -1;
    Dy := -Dy;
    TwoDy := - TwoDy;
  end;
  SetLength(Result, 1);
  Result[0] := Point(X1,Y1);
  if ((Dx <> 0) or (Dy <> 0)) then
  begin
    if (Dy <= Dx) then
    begin
      TwoDxAccumulatedError := 0;
      repeat
        Inc(CurrentX, Xinc);
        Inc(TwoDxAccumulatedError, TwoDy);
        if (TwoDxAccumulatedError > Dx) then
        begin
          Inc(CurrentY, Yinc);
          Dec(TwoDxAccumulatedError, TwoDx);
        end;
        Inc(Len);
        SetLength(Result, Len + 1);
        Result[Len] := Point(CurrentX,CurrentY);
      until (CurrentX = X2);
    end else
    begin
      TwoDyAccumulatedError := 0;
      repeat
        Inc(CurrentY, Yinc);
        Inc(TwoDyAccumulatedError, TwoDx);
        if (TwoDyAccumulatedError > Dy) then
        begin
          Inc(CurrentX, Xinc);
          Dec(TwoDyAccumulatedError, TwoDy);
        end;
        Inc(Len);
        SetLength(Result, Len + 1);
        Result[Len] := Point(CurrentX,CurrentY);
      until (CurrentY = Y2);
    end;
  end
end;

{/\
  Returns a TPointArray of the edge/border of the given Box.
/\}
function EdgeFromBox(const Box: TBox): TPointArray;
var
  Height, I, Len, WHM1, Width: Integer;
begin
  Width := (Box.x2 - Box.x1);
  Height := (Box.y2 - Box.y1);
  Len := ((Width * 2) + (Height * 2));
  SetLength(Result, Len);
  for I := 0 to Width do
  begin
    Result[i].x := Box.x1 + i;
    Result[i].y := Box.y1;
    Result[(Len - (Width - i)) - 1].x := Box.x1 + i;
    Result[(Len - (Width - i)) - 1].y := Box.y2;
  end;
  WHM1 := Width + (Height - 1);
  for I := 1 to (Height - 1) do
  begin
    Result[Width + I].x := Box.x1;
    Result[Width + I].y := Box.y1 + I;
    Result[WHM1 + I].x := Box.x2;
    Result[WHM1 + I].y := Box.y1 + I;
  end;
end;

{/\
  Returns a TPointArray of a the full given Box.
/\}
function TPAFromBox(const Box : TBox) : TPointArray;
var
  x, y: integer;
  l : integer;
begin;
  SetLength(Result, (Box.x2 - Box.x1 + 1) * (Box.y2 - Box.y1 + 1));
  l := 0;
  For x := box.x1 to Box.x2 do
    for y := box.y1 to box.y2 do
    begin;
      Result[l].x := x;
      Result[l].y := y;
      inc(l);
    end;
end;

{/\
  Returns a TPointArray of the outline of a ellipse.
/\}
function TPAFromEllipse(const CX, CY, XRadius, YRadius : Integer): TPointArray;
var
  x, y, a2, b2, h,
  d1, d2, sn, sd,
  a2t8, b2t8, Len : Integer;
begin
  SetLength(Result, 9999);
  Len := 0;
  Result[Len] := Point(CX + XRadius, CY);
  Inc(Len);
  Result[Len] := Point(CX, CY - YRadius);
  Inc(Len);
  Result[Len] := Point(CX - XRadius, CY);
  Inc(Len);
  Result[Len] := Point(CX, CY + YRadius);
  Inc(Len);
  x := 0;
  y := YRadius;
  a2 := XRadius * XRadius;
  b2 := y * y;
  a2t8 := a2 * 8;
  b2t8 := b2 * 8;
  h := b2 * 4 + a2 * (1 - 4 * y);
  d1 := 12 * b2;
  d2 := -a2t8 * (y - 1);
  sn := b2;
  sd := (a2 * y) - (a2 shr 1);

  while (sn < sd) do
  begin
    if (h > 0) then
    begin
      Dec(y);
      h := h + d2;
      sd := sd - a2;
      d2 := d2 + a2t8;
    end;
    Inc(x);
    h := h + d1;
    sn := sn + b2;
    d1 := d1 + b2t8;
    Result[Len] := Point(CX + X, CY + Y);
    Inc(Len);
    Result[Len] := Point(CX + X, CY - Y);
    Inc(Len);
    Result[Len] := Point(CX - X, CY + Y);
    Inc(Len);
    Result[Len] := Point(CX - X, CY - Y);
    Inc(Len);
  end;

  h := b2 * (4 * x * x + 4 * x + 1) + 4 * a2 * (y - 1) * (y - 1) - 4 * a2 * b2;
  d1 := b2t8 * (x + 1);
  d2 := -4 * a2 * (2 * y - 3);
  while (y > 1) do
  begin
    if (h < 0) then
    begin
      Inc(x);
      h := h + d1;
      d1 := d1 + b2t8;
    end;
    Dec(y);
    h := h + d2;
    d2 := d2 + a2t8;
    Result[Len] := Point(CX + X, CY + Y);
    Inc(Len);
    Result[Len] := Point(CX + X, CY - Y);
    Inc(Len);
    Result[Len] := Point(CX - X, CY + Y);
    Inc(Len);
    Result[Len] := Point(CX - X, CY - Y);
    Inc(Len);
  end;

  SetLength(Result, Len);
end;

{/\
  Returns a TPointArray of the outline of a ellipse.
/\}
function TPAFromCircle(const CX, CY, Radius: Integer): TPointArray;
begin
  Result := TPAFromEllipse(CX, CY, Radius, Radius);
end;

{/\
  Fills a Ellipse generated by TPAFromEllipse or TPAFromCircle.
/\}
procedure FillEllipse(var a: TPointArray);
var
  i, h, Hi: Integer;
  b, c: T2DPointArray;
begin
  b := FindTPARows(a);
  Hi := High(b);
  SetLength(c, Hi + 1);
  h := 0;
  for i := 0 to Hi do
  begin
    c[h] := TPAFromBox(GetTPABounds(b[i]));
    inc(h);
  end;
  a := MergeATPA(c);
end;

{/\
  Rotate the given TPA with A radians.
/\}

Function RotatePoints(Const P: TPointArray; A, cx, cy: Extended): TPointArray ;

Var
   I, L: Integer;
   CosA,SinA : extended;

Begin
  L := High(P);
  SetLength(Result, L + 1);
  CosA := Cos(a);
  SinA := Sin(a);
  For I := 0 To L Do
  Begin
    Result[I].X := Trunc(cx + CosA * (p[i].x - cx) - SinA * (p[i].y - cy));
    Result[I].Y := Trunc(cy + SinA * (p[i].x - cx) + CosA * (p[i].y - cy));
  End;
  // I recon it's faster than Point().
End;

{/\
  Rotate the given Point with A radians.
/\}

Function RotatePoint(Const p: TPoint; angle, mx, my: Extended): TPoint;

Begin
  Result.X := Trunc(mx + cos(angle) * (p.x - mx) - sin(angle) * (p.y - my));
  Result.Y := Trunc(my + sin(angle) * (p.x - mx) + cos(angle) * (p.y- my));
End;

{/\
  Returns the edges of the given TPA.
/\}

function FindTPAEdges(const p: TPointArray): TPointArray;
var
  b: T2DBoolArray;
  i, x, y, l, c: Integer;
  Box: TBox;
begin
  SetLength(Result, 0);
  l := Length(p);
  if (l = 0) then Exit;
  Box := GetTPABounds(p);
  x := (Box.x2 - Box.x1) + 3;
  y := (Box.y2 - Box.y1) + 3;
  SetLength(b, x);
  for i := 0 to x -1 do
  begin
    SetLength(b[i], y);
    FillChar(b[i][0],y,0);
  end;
  for i := 0 to l -1 do
    b[p[i].x +1 - Box.x1][p[i].y +1 - Box.y1] := True;
  SetLength(Result, l);
  c := 0;
  for i := 0 to l -1 do
  begin
    x := -1;
    while (x <= 1) do
    begin
      for y := -1 to 1 do
        try
          if not b[p[i].x + 1 + x - Box.x1][p[i].y + 1 + y - Box.y1] then
          begin
            Result[c] := p[i];
            Inc(c);
            x := 2;
            Break;
          end;
        except end;
      Inc(x);
    end;
  end;
  SetLength(Result, c);
end;

{/\
  Results true if a point is in a TPointArray.
  Notes: In actuallys means IN the array, not in the box shaped by the array.
/\}

function PointInTPA(const p: TPoint;const arP: TPointArray): Boolean;
var
  i, l: Integer;
begin
  l := High(arP);
  if l < 0 then
    Exit(false);
  Result := True;
  for i := 0 to l do
    if (arP[i].x = p.x) and (arP[i].y = p.y) then
      Exit;
  Result := False;
end;

{/\
  Removes the given ClearPoints from arP.
/\}

function ClearTPAFromTPA(const arP, ClearPoints: TPointArray): TPointArray;
var
  i, j, l, l2: Integer;
  Found: Boolean;
begin
  Setlength(result,0);
  l := High(arP);
  l2 := High(ClearPoints);
  for i := 0 to l do
  begin
    Found := false;
    for j := 0 to l2 do
      if (arP[i].x = ClearPoints[j].x) and (arP[i].y = ClearPoints[j].y) then
      begin
        Found := True;
        Break;
      end;
    if not found then
//    if (j = l2 + 1) then
    begin
      SetLength(Result, Length(Result) + 1);
      Result[High(Result)] := arP[i];
    end;
  end;
end;

{/\
  Removes all the doubles point from a TPA.
/\}
{Fixed by Cynic}

procedure ClearDoubleTPA(var TPA: TPointArray);
var
  i,j,k : integer;
  flag  : boolean;
  tmp     : TPointArray;
Begin
  i:=0;
  SetLength(tmp,0);
  while i < Length(TPA) do
  begin
    flag:=false;
    k:=0;
    while (k < Length(tmp)) and (not flag) do
    begin
      flag:=tmp[k]=TPA[i];
      Inc(k);
    end;
    if not flag then
    begin
      k:=Length(tmp);
      SetLength(tmp,k+1);
      tmp[k]:=TPA[i];
      Inc(i);
    end
    else
     begin
      j:=i;
      while j < length (TPA)-1 do
      begin
        TPA[j]:=TPA[j+1];
        inc(j);
      end;
      SetLength(TPA,Length(TPA)-1);
    end;
  end;
end;
{/\
  Uses Box to define an area around TotalTPA.
  Every point that is not in TotalTPA, but is in Box, is added to the Result.
  \\ This can be very handy if you want for example, can get all the colors of the background, but not of the actual object.
  \\ If you pass this all the colors of the background, it will returns the points of the object.
/\}

Function ReturnPointsNotInTPA(Const TotalTPA: TPointArray; const Box: TBox): TPointArray;
var
  x, y, w, h, i, l: integer;
  B: T2DBoolArray;
begin;
  w := Box.x2 - Box.x1;
  h := Box.y2 - Box.y1;
  if (w = 0) and (h = 0) then
    Exit;
  SetLength(b, w + 1, h + 1);
  for i := w downto 0 do
    FillChar(b[i][0],h+1,0);
  l := High(TotalTPA);
  x := 0;
  for i := 0 to l do
    if ((TotalTPA[i].x >= Box.x1) and (TotalTPA[i].x <= Box.x2) and
        (TotalTPA[i].y >= Box.y1) and (TotalTPA[i].y <= Box.y2)) then
    begin;
      Inc(x);
      B[TotalTPA[i].x-Box.x1][TotalTPA[i].y-Box.y1] := True;
    end;
  if x = 0 then
    Exit;
  SetLength(result,(w + 1) * (h + 1) - x);
  i := 0;
  for x := 0 to w do
    for y := 0 to h do
      if not B[x][y] then
      try
        Result[i].x := x + Box.x1;
        Result[i].y := y + Box.y1;
        Inc(i);
      except end;
  SetLength(b, 0);
  SetLength(Result, i);
end;

{/\
  Sorts a TPointArray by either X or Y. You have to define the max Point as well.
/\}

Procedure TPACountSort(Var TPA: TPointArray;const max: TPoint;Const SortOnX : Boolean);
Var
   c: T2DIntegerArray;
   I, II, III, hTPA, cc: Integer;
Begin
  hTPA := High(TPA);
  if hTPA < 1 then
    Exit;
  SetLength(c, max.X + 1,max.Y + 1);
  for i := max.x downto 0 do
    FillChar(c[i][0],(max.y+1)*sizeof(Integer),0);
  For I := 0 To hTPA Do
    c[TPA[I].x][TPA[I].y] := c[TPA[i].x][TPA[i].y] + 1;

  cc := 0;
  if SortOnX then
  begin
    For I := 0 To max.X  Do
      For II := 0 To max.Y  Do
      Begin
        For III := 0 To c[I][II] - 1 Do
        Begin
          TPA[cc].x := I;
          TPA[cc].y := II;
          cc := cc + 1;
        End;
      End;
  end else
  begin;
    For II := 0 To max.Y  Do
      For I := 0 To max.X  Do
      Begin
        For III := 0 To c[I][II] - 1 Do
        Begin
          TPA[cc].x := I;
          TPA[cc].y := II;
          cc := cc + 1;
        End;
      End;
  end;
End;


{/\
  Sorts a TPointArray by either X or Y. Allows one to pass a Base.
/\}

Procedure TPACountSortBase(Var TPA: TPointArray;const maxx, base: TPoint; const SortOnX : Boolean);
Var
   c: T2DIntegerArray;
   I, II, III, hTPA, cc: Integer;
   Max : TPoint;
Begin
  hTPA := High(TPA);
  if hTPA < 1 then
    Exit;
  max.X := maxx.X - base.X;
  max.Y := maxx.Y - base.Y;
  SetLength(c, max.X + 1,max.Y + 1);
  for i := max.x downto 0 do
    FillChar(c[i][0],(max.y+1)*sizeof(integer),0);
  hTPA := High(TPA);
  For I := 0 To hTPA Do
    c[TPA[I].x - base.X][TPA[I].y - base.Y] := c[TPA[i].x- base.X][TPA[i].y- base.Y] + 1;

  cc := 0;
  if SortOnX then
  begin
    For I := 0 To max.X  Do
      For II := 0 To max.Y  Do
      Begin
        For III := 0 To c[I][II] - 1 Do
        Begin
          TPA[cc].x := I + base.X;
          TPA[cc].y := II + base.Y;
          cc := cc + 1;
        End;
      End;
  end else
  begin;
    For II := 0 To max.Y  Do
      For I := 0 To max.X  Do
      Begin
        For III := 0 To c[I][II] - 1 Do
        Begin
          TPA[cc].x := I + base.X;
          TPA[cc].y := II + base.Y;
          cc := cc + 1;
        End;
      End;
  end;
End;

{/\
  Returns the sum of all integers in the array
/\}
function SumIntegerArray(const Ints : TIntegerArray): Integer;
var
  I, H: Integer;
begin
  Result := 0;
  H := High(Ints);
  for I := 0 to H do
    Result := Result + Ints[I];
end;

{/\
  Inverts the IntegerArray, last becomes first etc..
/\}
procedure InvertTIA(var tI: TIntegerArray);
var
  Temp: TIntegerArray;
  i, h: Integer;
begin
  h := High(tI);
  Temp := Copy(tI);
  for i := 0 to h do
    tI[i] := Temp[h - i];
end;

{/\
  Results the Average of an IntegerArray
/\}

function AverageTIA(const tI: TIntegerArray): Integer;
begin
  try Result := (SumIntegerArray(tI) div Length(tI)); except Result := 0; end;
end;

{/\
  Results the Average of an ExtendedArray
/\}
function AverageExtended(const tE: TExtendedArray): Extended;
var
  i, h: Integer;
begin
  Result := 1;
  try
    h := High(tE);
    for i := 0 to h do
      Result := (Result * tE[i]);
    Result := Power(Result, 1/(h + 1));
  except
    Result := 0.0;
  end;
end;

{/\
  Returns true if the two inputed TPA's are exactly the same (so the order matters)
/\}
function SameTPA(const aTPA, bTPA: TPointArray): Boolean;
var
  I: LongInt;
  h : integer;
begin
  Result := False;
  if (Length(aTPA) <> Length(bTPA)) then
    Exit;
  h := high(ATPA);
  for I := Low(aTPA) to h do
    if ((aTPA[I].X <> bTPA[I].X) or (aTPA[I].Y <> bTPA[I].Y)) then
      Exit;
  Result := True;
end;
{/\
  Returns true if the TPA is found as one of ATPA's sub-TPA's.. And again, order matters
/\}
function TPAInATPA(const TPA: TPointArray;const InATPA: T2DPointArray; var Index: LongInt): Boolean;
var
  I: LongInt;
  h : integer;
begin
  Result := True;
  h := high(inATPA);
    for I := Low(InATPA) to h do
      if (SameTPA(TPA, InATPA[I])) then
      begin
        Index := I;
        Exit;
      end;
  Result := False;
end;

procedure OffsetTPA(var TPA: TPointArray; const Offset: TPoint);
var
  i : integer;
begin
  for i := high(TPA) downto 0 do
  begin;
    inc(TPA[i].x,offset.x);
    inc(TPA[i].y,offset.y);
  end;
end;

procedure OffsetATPA(var ATPA: T2DPointArray; const Offset: TPoint);
var
  i : integer;
begin
  for i := high(ATPA) downto 0 do
    OffsetTPA(ATPA[i],Offset);
end;

function MiddleBox(b : TBox) : TPoint;
begin
  result := point((b.x2+b.x1) div 2,(b.y2+b.y1) div 2);
end;
